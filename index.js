// server.js
/* Webhook Helpdesk - fluxo contextual, robusto e profissional
   - Context-aware parsing: s√≥ interpreta "1/2/3/4" quando estamos no menu (IDLE).
   - Comandos globais: "menu", "voltar", "sair".
   - Suporta: autentica√ß√£o por matr√≠cula, abertura de ticket, listar tickets, pedir atendente.
   - Prote√ß√µes: sess√£o com TTL, fetch com timeout, tratamento de erros.
*/

const express = require("express");
const fetch = require("node-fetch");
const { v4: uuidv4 } = require("uuid");
const app = express();
app.use(express.json());

const SHEETBEST_URL = "https://api.sheetbest.com/sheets/4e9a0ce8-f805-46b9-bee8-402a3bc806c3";

// CONFIG
const SESSION_TTL_MS = 15 * 60 * 1000;
const FETCH_TIMEOUT_MS = 8000;

// SESS√ïES EM MEM√ìRIA
const sessions = new Map();

// util: fetch com timeout
async function fetchWithTimeout(url, opts = {}, timeout = FETCH_TIMEOUT_MS) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  try {
    const res = await fetch(url, { ...opts, signal: controller.signal });
    clearTimeout(id);
    return res;
  } catch (err) {
    clearTimeout(id);
    throw err;
  }
}

// limpa sess√µes expiradas
setInterval(() => {
  const now = Date.now();
  for (const [k, v] of sessions.entries()) {
    if (now - v.lastAt > SESSION_TTL_MS) sessions.delete(k);
  }
}, 60 * 1000);

// helpers SheetBest
async function getSheetData() {
  const r = await fetchWithTimeout(SHEETBEST_URL);
  if (!r.ok) throw new Error(`SheetBest GET: ${r.status}`);
  const json = await r.json();
  if (!Array.isArray(json)) throw new Error("SheetBest: resposta n√£o √© array");
  return json;
}
async function postToSheet(obj) {
  const r = await fetchWithTimeout(SHEETBEST_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(obj),
  });
  if (!r.ok) {
    const text = await r.text().catch(() => "");
    throw new Error(`SheetBest POST ${r.status} ${text}`);
  }
  return true;
}

// busca usu√°rio por matr√≠cula
async function findUserByMatricula(matricula) {
  const data = await getSheetData();
  return data.find(row => String(row.matricula || "").trim() === String(matricula).trim()) || null;
}

// cria ticket (registra na planilha)
async function createTicket(usuario, descricao, tipo = "ticket") {
  const ticketId = `T${Date.now().toString(36)}-${Math.random().toString(36).slice(2,6)}`;
  const payload = {
    tipo,
    ticketId,
    matricula: usuario.matricula || "",
    nome: usuario.nome || "",
    setor: usuario.setor || "",
    descricao,
    status: "Aberto",
    criado_em: new Date().toLocaleString("pt-BR"),
  };
  await postToSheet(payload);
  return ticketId;
}

// lista tickets por matr√≠cula
async function listTickets(matricula) {
  const data = await getSheetData();
  const tickets = data.filter(r => {
    const isTicket = (r.tipo && String(r.tipo).toLowerCase() === "ticket") || Boolean(r.ticketId);
    return isTicket && String(r.matricula || "").trim() === String(matricula).trim();
  });
  return tickets;
}

// menus e mensagens
function mainMenu(usuario) {
  const nome = usuario?.nome || "colaborador";
  return `üéØ Ol√° ${nome}!\nEscolha uma op√ß√£o:\n1 - Abrir chamado\n2 - Ver meus chamados\n3 - Falar com atendente\n4 - Encerrar atendimento\n\n(Digite o n√∫mero da op√ß√£o ou escreva 'menu' a qualquer momento)`;
}
function helpShort() {
  return "Dica: digite o n√∫mero da op√ß√£o (1-4) ou 'menu' / 'voltar' / 'sair'.";
}

// detecta inten√ß√£o de menu ‚Äî apenas quando estado IDLE
function detectMenuIntent(text, params, sessionState) {
  if (sessionState !== "IDLE") return null;

  // prioridade: par√¢metro expl√≠cito enviado pelo Dialogflow
  if (params && params.opcao) {
    const op = String(params.opcao).trim();
    if (/^[1-4]$/.test(op)) return op;
  }

  // se o texto for apenas um d√≠gito isolado
  if (/^\s*[1-4]\s*$/.test(text)) {
    return text.trim();
  }

  // mapeamentos por palavras-chave (come√ßo da frase ou palavra isolada)
  const t = text.toLowerCase().trim();
  if (/^(abrir|abrir chamado|quero abrir)/.test(t)) return "1";
  if (/^(ver|meus chamados|status|consultar)/.test(t)) return "2";
  if (/^(atendente|falar com|suporte|humano)/.test(t)) return "3";
  if (/^(sair|encerrar|fechar|finalizar)/.test(t)) return "4";

  return null;
}

// global commands that always work
function detectGlobalCommand(text) {
  if (!text) return null;
  const t = text.toLowerCase().trim();
  if (t === "menu" || t === "voltar") return "MENU";
  if (t === "sair" || t === "encerrar" || t === "exit") return "EXIT";
  return null;
}

// entrypoint
app.post("/webhook", async (req, res) => {
  try {
    const body = req.body || {};
    const sessionId = body.session || ("sess:" + (req.ip || "anon"));
    const params = body.queryResult?.parameters || {};
    const text = String(body.queryResult?.queryText || "").trim();

    // obter/atualizar sess√£o
    let sess = sessions.get(sessionId);
    if (!sess) {
      sess = { state: "WAIT_MATRICULA", lastAt: Date.now(), temp: {}, usuario: null, matricula: null };
      sessions.set(sessionId, sess);
    } else {
      sess.lastAt = Date.now();
    }

    // comandos globais
    const gcmd = detectGlobalCommand(text);
    if (gcmd === "MENU") {
      if (sess.usuario) {
        sess.state = "IDLE";
        return res.json({ fulfillmentText: mainMenu(sess.usuario) + "\n\n" + helpShort() });
      } else {
        sess.state = "WAIT_MATRICULA";
        return res.json({ fulfillmentText: "Por favor informe sua matr√≠cula para come√ßar." });
      }
    }
    if (gcmd === "EXIT") {
      sessions.delete(sessionId);
      return res.json({ fulfillmentText: "üëã Atendimento encerrado. At√© breve!" });
    }

    // State machine
    switch (sess.state) {
      case "WAIT_MATRICULA": {
        // aceita par√¢metro matricula ou texto com d√≠gitos
        const matricula = params.matricula ? String(params.matricula).trim() : (text.match(/\d{3,}/)?.[0] || null);
        if (!matricula) {
          return res.json({ fulfillmentText: "Por favor, informe sua matr√≠cula (somente n√∫meros)." });
        }
        // busca usu√°rio
        let usuario;
        try {
          usuario = await findUserByMatricula(matricula);
        } catch (err) {
          console.error("Erro SheetBest GET:", err);
          return res.json({ fulfillmentText: "‚ö†Ô∏è Erro ao consultar a base. Tente novamente em alguns instantes." });
        }
        if (!usuario) {
          // inicia fluxo de cadastro
          sess.state = "AWAIT_REG_NAME";
          sess.temp.matricula = matricula;
          return res.json({ fulfillmentText: "Matr√≠cula n√£o encontrada. Deseja cadastrar? Informe seu nome completo para iniciar o cadastro." });
        }
        // aut√™ntica
        sess.usuario = usuario;
        sess.matricula = matricula;
        sess.state = "IDLE";
        return res.json({ fulfillmentText: `‚úÖ Matr√≠cula confirmada! Bem-vindo(a), ${usuario.nome || "colaborador"} (${usuario.setor || "setor n√£o informado"}).\n\n${mainMenu(usuario)}` });
      }

      case "AWAIT_REG_NAME": {
        const name = params.nome || text || null;
        if (!name) return res.json({ fulfillmentText: "Por favor informe seu nome completo para cadastro." });
        sess.temp.name = name;
        sess.state = "AWAIT_REG_EMAIL";
        return res.json({ fulfillmentText: "Obrigado. Agora informe seu email." });
      }

      case "AWAIT_REG_EMAIL": {
        const email = params.email || text || null;
        if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return res.json({ fulfillmentText: "Informe um email v√°lido." });
        sess.temp.email = email;
        sess.state = "AWAIT_REG_PHONE";
        return res.json({ fulfillmentText: "Ok. Agora informe seu telefone (com DDD)." });
      }

      case "AWAIT_REG_PHONE": {
        const phone = params.telefone || text || null;
        if (!phone) return res.json({ fulfillmentText: "Informe um telefone v√°lido." });
        sess.temp.phone = phone;
        sess.state = "AWAIT_REG_DEPT";
        return res.json({ fulfillmentText: "Informe seu departamento/setor." });
      }

      case "AWAIT_REG_DEPT": {
        const dept = params.departamento || text || null;
        if (!dept) return res.json({ fulfillmentText: "Por favor informe seu departamento." });

        const newUser = {
          tipo: "user",
          matricula: sess.temp.matricula,
          nome: sess.temp.name,
          email: sess.temp.email,
          telefone: sess.temp.phone,
          setor: dept,
          criado_em: new Date().toLocaleString("pt-BR")
        };
        try {
          await postToSheet(newUser);
        } catch (err) {
          console.error("Erro SheetBest POST user:", err);
          sess.state = "WAIT_MATRICULA"; sess.temp = {};
          return res.json({ fulfillmentText: "‚ö†Ô∏è N√£o foi poss√≠vel cadastrar agora. Tente novamente mais tarde." });
        }
        sess.usuario = newUser; sess.matricula = newUser.matricula; sess.temp = {}; sess.state = "IDLE";
        return res.json({ fulfillmentText: `‚úÖ Cadastro criado! Bem-vindo(a), ${newUser.nome}.\n\n${mainMenu(newUser)}` });
      }

      case "IDLE": {
        // Detecta inten√ß√£o de menu somente aqui
        const opt = detectMenuIntent(text, params, sess.state);
        if (!opt) {
          return res.json({ fulfillmentText: "Por favor escolha uma op√ß√£o do menu (1-4) ou digite 'menu' para ver o menu novamente." });
        }
        if (opt === "1") {
          sess.state = "AWAIT_TICKET_DESCRIPTION";
          return res.json({ fulfillmentText: "Certo ‚Äî descreva brevemente o problema ou solicita√ß√£o (ou escreva 'voltar' para retornar ao menu)." });
        }
        if (opt === "2") {
          // listar tickets
          try {
            const tickets = await listTickets(sess.matricula);
            if (!tickets || tickets.length === 0) return res.json({ fulfillmentText: "Voc√™ n√£o possui chamados registrados. Deseja abrir um? Digite 1." });
            const listSummary = tickets.slice(-5).reverse().map(t => `‚Ä¢ ${t.ticketId || "(sem id)"} ‚Äî ${String(t.descricao||t.descri√ß√£o||"").slice(0,60)} (${t.status || "N/A"})`).join("\n");
            return res.json({ fulfillmentText: `Seus √∫ltimos chamados:\n${listSummary}\n\n${mainMenu(sess.usuario)}` });
          } catch (err) {
            console.error("Erro listar tickets:", err);
            return res.json({ fulfillmentText: "‚ö†Ô∏è N√£o foi poss√≠vel obter seus chamados no momento." });
          }
        }
        if (opt === "3") {
          sess.state = "AWAIT_ESCALATION_DESC";
          return res.json({ fulfillmentText: "Ok ‚Äî descreva o motivo para passar ao atendente humano." });
        }
        if (opt === "4") {
          sessions.delete(sessionId);
          return res.json({ fulfillmentText: "üëã Atendimento encerrado. At√© breve!" });
        }
        return res.json({ fulfillmentText: "Op√ß√£o inv√°lida. Digite 1,2,3 ou 4." });
      }

      case "AWAIT_TICKET_DESCRIPTION": {
        const desc = params.descricao || text || null;
        if (!desc) return res.json({ fulfillmentText: "Por favor descreva o problema para abrir o chamado (ou 'voltar' para menu)." });
        try {
          const ticketId = await createTicket(sess.usuario, desc);
          sess.state = "IDLE";
          return res.json({ fulfillmentText: `‚úÖ Chamado criado (ID: ${ticketId}).\n${mainMenu(sess.usuario)}` });
        } catch (err) {
          console.error("Erro criar ticket:", err);
          sess.state = "IDLE";
          return res.json({ fulfillmentText: "‚ö†Ô∏è Erro ao criar chamado. Tente novamente mais tarde." });
        }
      }

      case "AWAIT_ESCALATION_DESC": {
        const desc = params.descricao || text || null;
        if (!desc) return res.json({ fulfillmentText: "Descreva sucintamente o motivo do atendimento humano (ou 'voltar')." });
        try {
          const ticketId = await createTicket(sess.usuario, `[ESCALA] ${desc}`);
          sess.state = "IDLE";
          return res.json({ fulfillmentText: `‚úÖ Encaminhado ao atendimento humano (ID: ${ticketId}). Nossa equipe entrar√° em contato.\n\n${mainMenu(sess.usuario)}` });
        } catch (err) {
          console.error("Erro escalation:", err);
          sess.state = "IDLE";
          return res.json({ fulfillmentText: "‚ö†Ô∏è N√£o foi poss√≠vel encaminhar. Tente novamente mais tarde." });
        }
      }

      default:
        sess.state = "WAIT_MATRICULA";
        return res.json({ fulfillmentText: "Estado inv√°lido ‚Äî por favor informe sua matr√≠cula para come√ßar." });
    }

  } catch (err) {
    console.error("ERRO WEBHOOK:", err);
    return res.json({ fulfillmentText: "‚ö†Ô∏è Erro no servidor. Tente novamente." });
  }
});

// start
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`üöÄ Helpdesk webhook rodando na porta ${PORT}`));
